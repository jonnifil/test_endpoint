Инструкция локального развёртывания (если установлен docker и docker-compose):
Клонируем репу
Копируем содержимое папки docker-example в корень проекта
Выполняем docker-compose up -d --build (возможно придётся изменить проброс портов в docker-compose.yml, если указанные у вас заняты)
Выполняем docker-compose exec app composer install (проверяем, что создан файл .env и его содержимое аналогично .env.example)
Выполняем docker-compose exec app php artisan migrate

Роут доступен по адресу POST http://localhost:288/api/set-message

В структуре таблиц БД предусмотрены уникальные индексы не дающие создавать дубли сообщений, диалогов и клиентов.
Таблица clients - уникальное поле external_client_id
Таблица dialogs - уникальное поле client_id
Таблица messages - уникальное поле external_message_id

В связи с потенциально большой нагрузкой, select запросы по external_message_id не выполняются. 
Проверка уникальности происходит при записи в диалог. Дубли отсеиваются через try catch.

Все необходимые данные об относительно статичных сущностях (клиент, диалог) кешируются в Redis.
Ошибки конкурентных запросов (дубли сообщений) записываем в лог через очередь, чтобы работа с файлами ушла в фоновый процесс.

Возможно в метод MessageService::getDialogId стоит добавить блокировки в вызовы firstOrCreate, чтобы не потерять конкурирующие сообщения при первом посещении клиентом роута.
